# -*- coding: utf-8 -*-
"""Untitled16.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1NXGOtrOrJLdSgC7beyDYY057sZswVeAu
"""

#1ο dataset

#εισάγω τις απαραίτητες βιβλιοθήκες
import numpy as np
import pandas as pd
import seaborn as sns
import matplotlib.pyplot as plt
import warnings
from sklearn.preprocessing import MinMaxScaler
from imblearn.over_sampling import SMOTE
from sklearn.model_selection import train_test_split
from sklearn.svm import SVC
from sklearn.linear_model import LogisticRegression
from sklearn.neighbors import KNeighborsClassifier
from sklearn.naive_bayes import GaussianNB
from sklearn.metrics import accuracy_score, f1_score, precision_score, recall_score, classification_report, confusion_matrix
warnings.filterwarnings("ignore")


#εισάγω τα δεδομένα
diabetes= pd.read_csv("diabetes.csv")

# μέγεθος του dataset
print(diabetes.shape)

#πληροφορίες για το dataset
diabetes.info()
diabetes.describe()


#έλεγχος για ελλιπείς τιμές
diabetes.isnull().sum()

#έλεγχος για διπλότυπα
diabetes[diabetes.duplicated()]

#απομάκρυνση παρατηρήσεων με μηδενική τιμή
diabetes.drop(diabetes.index[diabetes['SkinThickness'] == 0], inplace = True)
diabetes.drop(diabetes.index[diabetes['BloodPressure'] == 0], inplace = True)
diabetes.drop(diabetes.index[diabetes['Glucose'] == 0], inplace = True)
diabetes.drop(diabetes.index[diabetes['BMI'] == 0], inplace = True)


#γράφημα πίτας
counts = diabetes["Outcome"].value_counts(dropna=False)

counts.plot.pie(autopct='%1.1f%%',colors=["seagreen", "pink"], labels=['Όχι ασθενής', 'Ασθενής'] )

plt.title('Ποσοστό ασθενών με διαβήτη')

plt.show()

#Boxplot
diabetes.boxplot(column="Glucose", by="Outcome",showmeans=True,grid=True,color="green")
plt.title(' ')
plt.xlabel('Όχι ασθενής    Ασθενής')
plt.ylabel('Τιμή Γλυκόζης')

#Διάγραμμα διασποράς
diabetes.plot.scatter("Age", "Pregnancies", s=None, c="green")


#ραβδόγραμμα με το outcome
plt.figure(figsize=(5, 5))
sns.countplot(x='Outcome',hue='Outcome', data=diabetes, palette="Spectral_r")

plt.xticks([0, 1], ('Μη ασθενής', 'Ασθενής'))
plt.ylabel("Πλήθος")
plt.show()


#ιστογράμματα για κάθε χαρακτηριστικό

sns.set(style="whitegrid")
fig,axs = plt.subplots(4,2, figsize = (8,10))
sns.histplot(data=diabetes, x="Pregnancies", kde=True, color="skyblue", ax=axs[0, 0])
sns.histplot(data=diabetes, x="Glucose", kde=True, color="olive", ax=axs[0, 1])
sns.histplot(data=diabetes, x="BloodPressure", kde=True, color="gold", ax=axs[1, 0])
sns.histplot(data=diabetes, x="SkinThickness", kde=True, color="teal", ax=axs[1, 1])
sns.histplot(data=diabetes, x="Insulin", kde=True, color="teal", ax=axs[2, 0])
sns.histplot(data=diabetes, x="BMI", kde=True, color="blue", ax=axs[2, 1])
sns.histplot(data=diabetes, x="Age", kde=True, color="purple", ax=axs[3,0])
sns.histplot(data=diabetes, x="Outcome", kde=False, color="pink", ax=axs[3,1])
fig.tight_layout()

# Συσχετίσεις μεταξύ των χαρακτηριστικών
diabetes.corr()

# οπτικοποίηση των συσχετίσεων heatmap
f, ax = plt.subplots(figsize = (12,12))
sns.heatmap(diabetes.corr(), annot = True, linewidths = 0.5, linecolor = "white", fmt = ".4f", ax = ax,cmap="BrBG")
plt.show()
#δημιουργία ιστογραμμάτων με μεταβλητή στόχο
data_d0 = diabetes[diabetes['Outcome'] == 0]
data_d1 = diabetes[diabetes['Outcome'] == 1]

data_d0_samp = data_d0.sample(268,replace = False)
data_bal = pd.concat([data_d1, data_d0_samp])

def look_at_distr_hist(*args, data_num=None, data_cat=None, class_feature="Outcome"):
    if data_num is not None:
        plt.figure(figsize = [20, 18])
        counter = 0
        for i in data_num.columns:
            counter += 1
            plt.subplot(3, 3, counter)
            sns.histplot(data = diabetes, x = diabetes[str(i)], hue = diabetes[class_feature], multiple  = 'dodge', palette={0: 'blue', 1: 'red'}, kde=True)
            plt.title(f'--- "{i}" per count ---')
        plt.plot()
look_at_distr_hist(data_num=data_bal, class_feature="Outcome")



#Προετοιμασία πριν την εκπαίδευση




#Διαχωρισμός δεδομένων
x = diabetes.drop(["Outcome"], axis = 1)
y = diabetes["Outcome"]


#split
x_train, x_test, y_train, y_test = train_test_split(x,y , test_size = 0.2, random_state = 42)
x_train.shape
x_test.shape



#  SMOTE

print("Ποσοστό ασθενών στο σύνολο εκπαίδευσης πριν την εφαρμογή του Smote :",y_train.value_counts(normalize=True)[1]/(y_train.value_counts(normalize=True)[0]+y_train.value_counts(normalize=True)[1])*100,"%")
print("Ποσοστό μη ασθενών στο σύνολο εκπαίδευσης πριν την εφαρμογή του Smote :",y_train.value_counts(normalize=True)[0]/(y_train.value_counts(normalize=True)[0]+y_train.value_counts(normalize=True)[1])*100,"%")

print()
print('Μέγεθος συνόλου εκπαίδευσης πριν την εφαρμογή του SMOTE :', x_train.shape)

smote = SMOTE(random_state=42)
x_train,y_train = smote.fit_resample(x_train,y_train)

print('Μέγεθος συνόλου εκπαίδευσης μετά την εφαρμογή του  SMOTE : ', x_train.shape)
print()

print("Ποσοστό ασθενών στο σύνολο εκπαίδευσης μετά την εφαρμογή του Smote :",y_train.value_counts(normalize=True)[1]/(y_train.value_counts(normalize=True)[0]+y_train.value_counts(normalize=True)[1])*100,"%")
print("Ποσοστό μη ασθενών στο σύνολο εκπαίδευσης μετά την εφαρμογή του Smote :",y_train.value_counts(normalize=True)[0]/(y_train.value_counts(normalize=True)[0]+y_train.value_counts(normalize=True)[1])*100,"%")



#Logistic Regression
model = LogisticRegression()
model.fit(x_train, y_train)
predicted=model.predict(x_test)
conf = confusion_matrix(y_test, predicted)
print ("Confusion Matrix : \n", conf)
print()
print ("The accuracy of Logistic Regression is : ", accuracy_score(y_test, predicted)*100, "%")
print()
print("Precision score for Logistic Regression is :",precision_score(y_test, predicted,)*100, "%")
print()
print("Recall score for Logistic Regression is :",recall_score(y_test, predicted,)*100, "%")

conf = confusion_matrix(y_test, predicted)
print ("Confusion Matrix : \n", conf)
print()

group_names = ["True Neg","False Pos","False Neg","True Pos"]
group_counts = ["{0:0.0f}".format(value) for value in
                conf.flatten()]
group_percentages = ["{0:.2%}".format(value) for value in
                     conf.flatten()/np.sum(conf)]
labels = [f"{v1}\n{v2}\n{v3}" for v1, v2, v3 in
          zip(group_names,group_counts,group_percentages)]
labels = np.asarray(labels).reshape(2,2)
sns.heatmap(conf, annot=labels, fmt="", cmap="Greens")



# Gaussian Naive Bayes
model = GaussianNB()
model.fit(x_train, y_train)

predicted = model.predict(x_test)

conf = confusion_matrix(y_test, predicted)
print ("Confusion Matrix : \n", conf)
print()
print ("The accuracy of Gaussian Naive Bayes is : ", accuracy_score(y_test, predicted)*100, "%")
print()
print("Precision score for Gaussian Naive Bayes is :",precision_score(y_test, predicted,)*100, "%")
print()
print("Recall score for Gaussian Naive Bayes is :",recall_score(y_test, predicted,)*100, "%")


group_names = ["True Neg","False Pos","False Neg","True Pos"]
group_counts = ["{0:0.0f}".format(value) for value in
                conf.flatten()]
group_percentages = ["{0:.2%}".format(value) for value in
                     conf.flatten()/np.sum(conf)]
labels = [f"{v1}\n{v2}\n{v3}" for v1, v2, v3 in
          zip(group_names,group_counts,group_percentages)]
labels = np.asarray(labels).reshape(2,2)
sns.heatmap(conf, annot=labels, fmt="", cmap="Blues")



#K Nearest Neighbours
model = KNeighborsClassifier(n_neighbors = 3)
model.fit(x_train, y_train)
predicted = model.predict(x_test)

print()
print ("The accuracy of KNN is : ", accuracy_score(y_test, predicted)*100, "%")
print()
print("Precision score for KNN is :",precision_score(y_test, predicted,)*100, "%")
print()
print("Recall score for KNN is :",recall_score(y_test, predicted,)*100, "%")

conf = confusion_matrix(y_test, predicted)
print ("Confusion Matrix : \n", conf)
print()

group_names = ["True Neg","False Pos","False Neg","True Pos"]
group_counts = ["{0:0.0f}".format(value) for value in
                conf.flatten()]
group_percentages = ["{0:.2%}".format(value) for value in
                     conf.flatten()/np.sum(conf)]
labels = [f"{v1}\n{v2}\n{v3}" for v1, v2, v3 in
          zip(group_names,group_counts,group_percentages)]
labels = np.asarray(labels).reshape(2,2)
sns.heatmap(conf, annot=labels, fmt="", cmap="Reds")

#Support Vector Machine
model = SVC()
model.fit(x_train, y_train)
predicted = model.predict(x_test)

conf = confusion_matrix(y_test, predicted)
print ("Confusion Matrix : \n", conf)
print()
print ("The accuracy of SVM is : ", accuracy_score(y_test, predicted)*100, "%")
print()
print("Precision score for SVM is :",precision_score(y_test, predicted,)*100, "%")
print()
print("Recall score for SVM is :",recall_score(y_test, predicted,)*100, "%")
#sns.heatmap(conf, annot=True)
group_names = ["True Neg","False Pos","False Neg","True Pos"]
group_counts = ["{0:0.0f}".format(value) for value in
                conf.flatten()]
group_percentages = ["{0:.2%}".format(value) for value in
                     conf.flatten()/np.sum(conf)]
labels = [f"{v1}\n{v2}\n{v3}" for v1, v2, v3 in
          zip(group_names,group_counts,group_percentages)]
labels = np.asarray(labels).reshape(2,2)
sns.heatmap(conf, annot=labels, fmt="", cmap="Oranges")